//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;

use crate::*;

extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/metal/mtlindirectrendercommand?language=objc)
    pub unsafe trait MTLIndirectRenderCommand: NSObjectProtocol {
        #[cfg(all(feature = "MTLAllocation", feature = "MTLRenderPipeline"))]
        #[unsafe(method(setRenderPipelineState:))]
        #[unsafe(method_family = none)]
        fn setRenderPipelineState(
            &self,
            pipeline_state: &ProtocolObject<dyn MTLRenderPipelineState>,
        );

        #[cfg(all(
            feature = "MTLAllocation",
            feature = "MTLBuffer",
            feature = "MTLResource"
        ))]
        /// # Safety
        ///
        /// - `buffer` may need to be synchronized.
        /// - `buffer` may be unretained, you must ensure it is kept alive while in use.
        /// - `buffer` contents should be of the correct type.
        /// - `offset` might not be bounds-checked.
        /// - `index` might not be bounds-checked.
        #[unsafe(method(setVertexBuffer:offset:atIndex:))]
        #[unsafe(method_family = none)]
        unsafe fn setVertexBuffer_offset_atIndex(
            &self,
            buffer: &ProtocolObject<dyn MTLBuffer>,
            offset: NSUInteger,
            index: NSUInteger,
        );

        #[cfg(all(
            feature = "MTLAllocation",
            feature = "MTLBuffer",
            feature = "MTLResource"
        ))]
        /// # Safety
        ///
        /// - `buffer` may need to be synchronized.
        /// - `buffer` may be unretained, you must ensure it is kept alive while in use.
        /// - `buffer` contents should be of the correct type.
        /// - `offset` might not be bounds-checked.
        /// - `index` might not be bounds-checked.
        #[unsafe(method(setFragmentBuffer:offset:atIndex:))]
        #[unsafe(method_family = none)]
        unsafe fn setFragmentBuffer_offset_atIndex(
            &self,
            buffer: &ProtocolObject<dyn MTLBuffer>,
            offset: NSUInteger,
            index: NSUInteger,
        );

        #[cfg(all(
            feature = "MTLAllocation",
            feature = "MTLBuffer",
            feature = "MTLResource"
        ))]
        /// sets vertex buffer at specified index with provided offset and stride.
        /// only call this when the buffer-index is part of the vertexDescriptor and
        /// has set its stride to `MTLBufferLayoutStrideDynamic`
        ///
        /// # Safety
        ///
        /// - `buffer` may need to be synchronized.
        /// - `buffer` may be unretained, you must ensure it is kept alive while in use.
        /// - `buffer` contents should be of the correct type.
        /// - `offset` might not be bounds-checked.
        /// - `stride` might not be bounds-checked.
        /// - `index` might not be bounds-checked.
        #[unsafe(method(setVertexBuffer:offset:attributeStride:atIndex:))]
        #[unsafe(method_family = none)]
        unsafe fn setVertexBuffer_offset_attributeStride_atIndex(
            &self,
            buffer: &ProtocolObject<dyn MTLBuffer>,
            offset: NSUInteger,
            stride: NSUInteger,
            index: NSUInteger,
        );

        #[cfg(all(
            feature = "MTLAllocation",
            feature = "MTLBuffer",
            feature = "MTLResource"
        ))]
        /// # Safety
        ///
        /// - `patchCount` might not be bounds-checked.
        /// - `patch_index_buffer` may need to be synchronized.
        /// - `patch_index_buffer` may be unretained, you must ensure it is kept alive while in use.
        /// - `patch_index_buffer` contents should be of the correct type.
        /// - `patchIndexBufferOffset` might not be bounds-checked.
        /// - `instanceCount` might not be bounds-checked.
        /// - `buffer` may need to be synchronized.
        /// - `buffer` may be unretained, you must ensure it is kept alive while in use.
        /// - `buffer` contents should be of the correct type.
        /// - `offset` might not be bounds-checked.
        /// - `instanceStride` might not be bounds-checked.
        #[unsafe(method(drawPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:instanceCount:baseInstance:tessellationFactorBuffer:tessellationFactorBufferOffset:tessellationFactorBufferInstanceStride:))]
        #[unsafe(method_family = none)]
        unsafe fn drawPatches_patchStart_patchCount_patchIndexBuffer_patchIndexBufferOffset_instanceCount_baseInstance_tessellationFactorBuffer_tessellationFactorBufferOffset_tessellationFactorBufferInstanceStride(
            &self,
            number_of_patch_control_points: NSUInteger,
            patch_start: NSUInteger,
            patch_count: NSUInteger,
            patch_index_buffer: Option<&ProtocolObject<dyn MTLBuffer>>,
            patch_index_buffer_offset: NSUInteger,
            instance_count: NSUInteger,
            base_instance: NSUInteger,
            buffer: &ProtocolObject<dyn MTLBuffer>,
            offset: NSUInteger,
            instance_stride: NSUInteger,
        );

        #[cfg(all(
            feature = "MTLAllocation",
            feature = "MTLBuffer",
            feature = "MTLResource"
        ))]
        /// # Safety
        ///
        /// - `patchCount` might not be bounds-checked.
        /// - `patch_index_buffer` may need to be synchronized.
        /// - `patch_index_buffer` may be unretained, you must ensure it is kept alive while in use.
        /// - `patch_index_buffer` contents should be of the correct type.
        /// - `patchIndexBufferOffset` might not be bounds-checked.
        /// - `control_point_index_buffer` may need to be synchronized.
        /// - `control_point_index_buffer` may be unretained, you must ensure it is kept alive while in use.
        /// - `control_point_index_buffer` contents should be of the correct type.
        /// - `controlPointIndexBufferOffset` might not be bounds-checked.
        /// - `instanceCount` might not be bounds-checked.
        /// - `buffer` may need to be synchronized.
        /// - `buffer` may be unretained, you must ensure it is kept alive while in use.
        /// - `buffer` contents should be of the correct type.
        /// - `offset` might not be bounds-checked.
        /// - `instanceStride` might not be bounds-checked.
        #[unsafe(method(drawIndexedPatches:patchStart:patchCount:patchIndexBuffer:patchIndexBufferOffset:controlPointIndexBuffer:controlPointIndexBufferOffset:instanceCount:baseInstance:tessellationFactorBuffer:tessellationFactorBufferOffset:tessellationFactorBufferInstanceStride:))]
        #[unsafe(method_family = none)]
        unsafe fn drawIndexedPatches_patchStart_patchCount_patchIndexBuffer_patchIndexBufferOffset_controlPointIndexBuffer_controlPointIndexBufferOffset_instanceCount_baseInstance_tessellationFactorBuffer_tessellationFactorBufferOffset_tessellationFactorBufferInstanceStride(
            &self,
            number_of_patch_control_points: NSUInteger,
            patch_start: NSUInteger,
            patch_count: NSUInteger,
            patch_index_buffer: Option<&ProtocolObject<dyn MTLBuffer>>,
            patch_index_buffer_offset: NSUInteger,
            control_point_index_buffer: &ProtocolObject<dyn MTLBuffer>,
            control_point_index_buffer_offset: NSUInteger,
            instance_count: NSUInteger,
            base_instance: NSUInteger,
            buffer: &ProtocolObject<dyn MTLBuffer>,
            offset: NSUInteger,
            instance_stride: NSUInteger,
        );

        #[cfg(feature = "MTLRenderCommandEncoder")]
        /// # Safety
        ///
        /// - `vertexCount` might not be bounds-checked.
        /// - `instanceCount` might not be bounds-checked.
        #[unsafe(method(drawPrimitives:vertexStart:vertexCount:instanceCount:baseInstance:))]
        #[unsafe(method_family = none)]
        unsafe fn drawPrimitives_vertexStart_vertexCount_instanceCount_baseInstance(
            &self,
            primitive_type: MTLPrimitiveType,
            vertex_start: NSUInteger,
            vertex_count: NSUInteger,
            instance_count: NSUInteger,
            base_instance: NSUInteger,
        );

        #[cfg(all(
            feature = "MTLAllocation",
            feature = "MTLArgument",
            feature = "MTLBuffer",
            feature = "MTLRenderCommandEncoder",
            feature = "MTLResource"
        ))]
        /// # Safety
        ///
        /// - `indexCount` might not be bounds-checked.
        /// - `index_buffer` may need to be synchronized.
        /// - `index_buffer` may be unretained, you must ensure it is kept alive while in use.
        /// - `index_buffer` contents should be of the correct type.
        /// - `indexBufferOffset` might not be bounds-checked.
        /// - `instanceCount` might not be bounds-checked.
        #[unsafe(method(drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:baseVertex:baseInstance:))]
        #[unsafe(method_family = none)]
        unsafe fn drawIndexedPrimitives_indexCount_indexType_indexBuffer_indexBufferOffset_instanceCount_baseVertex_baseInstance(
            &self,
            primitive_type: MTLPrimitiveType,
            index_count: NSUInteger,
            index_type: MTLIndexType,
            index_buffer: &ProtocolObject<dyn MTLBuffer>,
            index_buffer_offset: NSUInteger,
            instance_count: NSUInteger,
            base_vertex: NSInteger,
            base_instance: NSUInteger,
        );

        /// # Safety
        ///
        /// `index` might not be bounds-checked.
        #[unsafe(method(setObjectThreadgroupMemoryLength:atIndex:))]
        #[unsafe(method_family = none)]
        unsafe fn setObjectThreadgroupMemoryLength_atIndex(
            &self,
            length: NSUInteger,
            index: NSUInteger,
        );

        #[cfg(all(
            feature = "MTLAllocation",
            feature = "MTLBuffer",
            feature = "MTLResource"
        ))]
        /// # Safety
        ///
        /// - `buffer` may need to be synchronized.
        /// - `buffer` may be unretained, you must ensure it is kept alive while in use.
        /// - `buffer` contents should be of the correct type.
        /// - `offset` might not be bounds-checked.
        /// - `index` might not be bounds-checked.
        #[unsafe(method(setObjectBuffer:offset:atIndex:))]
        #[unsafe(method_family = none)]
        unsafe fn setObjectBuffer_offset_atIndex(
            &self,
            buffer: &ProtocolObject<dyn MTLBuffer>,
            offset: NSUInteger,
            index: NSUInteger,
        );

        #[cfg(all(
            feature = "MTLAllocation",
            feature = "MTLBuffer",
            feature = "MTLResource"
        ))]
        /// # Safety
        ///
        /// - `buffer` may need to be synchronized.
        /// - `buffer` may be unretained, you must ensure it is kept alive while in use.
        /// - `buffer` contents should be of the correct type.
        /// - `offset` might not be bounds-checked.
        /// - `index` might not be bounds-checked.
        #[unsafe(method(setMeshBuffer:offset:atIndex:))]
        #[unsafe(method_family = none)]
        unsafe fn setMeshBuffer_offset_atIndex(
            &self,
            buffer: &ProtocolObject<dyn MTLBuffer>,
            offset: NSUInteger,
            index: NSUInteger,
        );

        #[cfg(feature = "MTLTypes")]
        #[unsafe(method(drawMeshThreadgroups:threadsPerObjectThreadgroup:threadsPerMeshThreadgroup:))]
        #[unsafe(method_family = none)]
        fn drawMeshThreadgroups_threadsPerObjectThreadgroup_threadsPerMeshThreadgroup(
            &self,
            threadgroups_per_grid: MTLSize,
            threads_per_object_threadgroup: MTLSize,
            threads_per_mesh_threadgroup: MTLSize,
        );

        #[cfg(feature = "MTLTypes")]
        #[unsafe(method(drawMeshThreads:threadsPerObjectThreadgroup:threadsPerMeshThreadgroup:))]
        #[unsafe(method_family = none)]
        fn drawMeshThreads_threadsPerObjectThreadgroup_threadsPerMeshThreadgroup(
            &self,
            threads_per_grid: MTLSize,
            threads_per_object_threadgroup: MTLSize,
            threads_per_mesh_threadgroup: MTLSize,
        );

        #[unsafe(method(setBarrier))]
        #[unsafe(method_family = none)]
        fn setBarrier(&self);

        #[unsafe(method(clearBarrier))]
        #[unsafe(method_family = none)]
        fn clearBarrier(&self);

        #[cfg(feature = "MTLDepthStencil")]
        #[unsafe(method(setDepthStencilState:))]
        #[unsafe(method_family = none)]
        fn setDepthStencilState(
            &self,
            depth_stencil_state: Option<&ProtocolObject<dyn MTLDepthStencilState>>,
        );

        #[unsafe(method(setDepthBias:slopeScale:clamp:))]
        #[unsafe(method_family = none)]
        fn setDepthBias_slopeScale_clamp(
            &self,
            depth_bias: c_float,
            slope_scale: c_float,
            clamp: c_float,
        );

        #[cfg(feature = "MTLRenderCommandEncoder")]
        #[unsafe(method(setDepthClipMode:))]
        #[unsafe(method_family = none)]
        fn setDepthClipMode(&self, depth_clip_mode: MTLDepthClipMode);

        #[cfg(feature = "MTLRenderCommandEncoder")]
        #[unsafe(method(setCullMode:))]
        #[unsafe(method_family = none)]
        fn setCullMode(&self, cull_mode: MTLCullMode);

        #[cfg(feature = "MTLRenderCommandEncoder")]
        #[unsafe(method(setFrontFacingWinding:))]
        #[unsafe(method_family = none)]
        fn setFrontFacingWinding(&self, front_facing_windning: MTLWinding);

        #[cfg(feature = "MTLRenderCommandEncoder")]
        #[unsafe(method(setTriangleFillMode:))]
        #[unsafe(method_family = none)]
        fn setTriangleFillMode(&self, fill_mode: MTLTriangleFillMode);

        #[unsafe(method(reset))]
        #[unsafe(method_family = none)]
        fn reset(&self);
    }
);

extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/metal/mtlindirectcomputecommand?language=objc)
    pub unsafe trait MTLIndirectComputeCommand: NSObjectProtocol {
        #[cfg(all(feature = "MTLAllocation", feature = "MTLComputePipeline"))]
        #[unsafe(method(setComputePipelineState:))]
        #[unsafe(method_family = none)]
        fn setComputePipelineState(
            &self,
            pipeline_state: &ProtocolObject<dyn MTLComputePipelineState>,
        );

        #[cfg(all(
            feature = "MTLAllocation",
            feature = "MTLBuffer",
            feature = "MTLResource"
        ))]
        /// # Safety
        ///
        /// - `buffer` may need to be synchronized.
        /// - `buffer` may be unretained, you must ensure it is kept alive while in use.
        /// - `buffer` contents should be of the correct type.
        /// - `offset` might not be bounds-checked.
        /// - `index` might not be bounds-checked.
        #[unsafe(method(setKernelBuffer:offset:atIndex:))]
        #[unsafe(method_family = none)]
        unsafe fn setKernelBuffer_offset_atIndex(
            &self,
            buffer: &ProtocolObject<dyn MTLBuffer>,
            offset: NSUInteger,
            index: NSUInteger,
        );

        #[cfg(all(
            feature = "MTLAllocation",
            feature = "MTLBuffer",
            feature = "MTLResource"
        ))]
        /// sets kernel buffer at specified index with provided offset and stride.
        /// only call this when the buffer-index is part of the stageInputDescriptor
        /// and has set its stride to `MTLBufferLayoutStrideDynamic`
        ///
        /// # Safety
        ///
        /// - `buffer` may need to be synchronized.
        /// - `buffer` may be unretained, you must ensure it is kept alive while in use.
        /// - `buffer` contents should be of the correct type.
        /// - `offset` might not be bounds-checked.
        /// - `stride` might not be bounds-checked.
        /// - `index` might not be bounds-checked.
        #[unsafe(method(setKernelBuffer:offset:attributeStride:atIndex:))]
        #[unsafe(method_family = none)]
        unsafe fn setKernelBuffer_offset_attributeStride_atIndex(
            &self,
            buffer: &ProtocolObject<dyn MTLBuffer>,
            offset: NSUInteger,
            stride: NSUInteger,
            index: NSUInteger,
        );

        #[cfg(feature = "MTLTypes")]
        #[unsafe(method(concurrentDispatchThreadgroups:threadsPerThreadgroup:))]
        #[unsafe(method_family = none)]
        fn concurrentDispatchThreadgroups_threadsPerThreadgroup(
            &self,
            threadgroups_per_grid: MTLSize,
            threads_per_threadgroup: MTLSize,
        );

        #[cfg(feature = "MTLTypes")]
        #[unsafe(method(concurrentDispatchThreads:threadsPerThreadgroup:))]
        #[unsafe(method_family = none)]
        fn concurrentDispatchThreads_threadsPerThreadgroup(
            &self,
            threads_per_grid: MTLSize,
            threads_per_threadgroup: MTLSize,
        );

        #[unsafe(method(setBarrier))]
        #[unsafe(method_family = none)]
        fn setBarrier(&self);

        #[unsafe(method(clearBarrier))]
        #[unsafe(method_family = none)]
        fn clearBarrier(&self);

        #[unsafe(method(setImageblockWidth:height:))]
        #[unsafe(method_family = none)]
        fn setImageblockWidth_height(&self, width: NSUInteger, height: NSUInteger);

        #[unsafe(method(reset))]
        #[unsafe(method_family = none)]
        fn reset(&self);

        /// # Safety
        ///
        /// `index` might not be bounds-checked.
        #[unsafe(method(setThreadgroupMemoryLength:atIndex:))]
        #[unsafe(method_family = none)]
        unsafe fn setThreadgroupMemoryLength_atIndex(&self, length: NSUInteger, index: NSUInteger);

        #[cfg(feature = "MTLTypes")]
        #[unsafe(method(setStageInRegion:))]
        #[unsafe(method_family = none)]
        fn setStageInRegion(&self, region: MTLRegion);
    }
);

<?xml version="1.0"?>
<!-- ***** BEGIN LICENSE BLOCK *****
   - Version: MPL 1.1/GPL 2.0/LGPL 2.1
   -
   - The contents of this file are subject to the Mozilla Public License Version
   - 1.1 (the "License"); you may not use this file except in compliance with
   - the License. You may obtain a copy of the License at
   - http://www.mozilla.org/MPL/
   -
   - Software distributed under the License is distributed on an "AS IS" basis,
   - WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   - for the specific language governing rights and limitations under the
   - License.
   -
   - The Original Code is the Instantbird messenging client, released
   - 2007.
   -
   - The Initial Developer of the Original Code is
   - Florian QUEZE <florian@instantbird.org>.
   - Portions created by the Initial Developer are Copyright (C) 2007
   - the Initial Developer. All Rights Reserved.
   -
   - Contributor(s):
   -
   - Alternatively, the contents of this file may be used under the terms of
   - either the GNU General Public License Version 2 or later (the "GPL"), or
   - the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   - in which case the provisions of the GPL or the LGPL are applicable instead
   - of those above. If you wish to allow use of your version of this file only
   - under the terms of either the GPL or the LGPL, and not to allow others to
   - use your version of this file under the terms of the MPL, indicate your
   - decision by deleting the provisions above and replace them with the notice
   - and other provisions required by the GPL or the LGPL. If you do not delete
   - the provisions above, a recipient may use your version of this file under
   - the terms of any one of the MPL, the GPL or the LGPL.
   -
   - ***** END LICENSE BLOCK ***** -->


<!DOCTYPE bindings [
  <!ENTITY % instantbirdDTD SYSTEM "chrome://instantbird/locale/instantbird.dtd">
  %instantbirdDTD;
]>

<bindings id="conversationBindings"
          xmlns="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl">

  <binding id="conversation">
    <resources>
      <stylesheet src="chrome://instantbird/skin/instantbird.css"/>
    </resources>
    <content>
      <xul:vbox class="convBox" flex="1">
        <xul:browser flex="1" class="browser" anonid="browser" type="content"/>
        <xul:splitter anonid="splitter" class="splitter"/>
        <xul:deck anonid="conv-bottom" class="conv-bottom" selectedIndex="1">
          <xul:vbox>
            <xul:toolbar anonid="conv-toolbar">
              <xul:toolbarbutton label="Bold" oncommand="this.editorDoCommand('bold');"/>
              <xul:toolbarbutton label="Italic" oncommand="this.editorDoCommand('italic');"/>
              <xul:toolbarbutton label="Underline" oncommand="this.editorDoCommand('underline');"/>
            </xul:toolbar>
            <xul:editor anonid="editor" editortype="html" src="about:blank" flex="1"/>
          </xul:vbox>
          <xul:textbox anonid="input" multiline="true" spellcheck="true" flex="1"/>
        </xul:deck>
      </xul:vbox>
    </content>
    <implementation implements="nsIWebProgressListener">
     <constructor>
      <![CDATA[
       document.getAnonymousElementByAttribute(this, "anonid", "input")
               .addEventListener("keypress", this.onSendMsg, false);

       var browser = document.getAnonymousElementByAttribute(this, "anonid", "browser");
       var docShell = browser.docShell;
       docShell.allowJavascript = false;
       docShell.allowAuth = false;
       docShell.allowPlugins = false;
       docShell.allowMetaRedirects = false;
       docShell.allowSubframes = false;
       docShell.allowImages = false;
       var url = 'data:text/html,<html><head><link rel="stylesheet" type="text/css" href="chrome://instantbird/skin/conv.css" /></head>';
       url += '<body id="ibcontent"></body></html>';
       browser.setAttribute("src", url);//"chrome://instantbird/content/conv.html"
       browser.addProgressListener(this);

       var editor = document.getAnonymousElementByAttribute(this, "anonid", "editor");
       editor.addEventListener("keypress", this.onSendHTMLMsg, false);
       //this doesn't work at the moment
       //editor.contentDocument.designMode = "on";
       //setTimeout(function() { editor.contentWindow.focus(); }, 100);
      ]]>
     </constructor>

     <destructor>
      <![CDATA[
        this._conv.close();
      ]]>
     </destructor>

     <field name="loaded">false</field>
     <field name="messageQueue">[]</field>

     <method name="addMsg">
      <parameter name="aMsg"/>
      <body>
      <![CDATA[
        if (this.loaded)
          this._addMsg(aMsg);
        else
          this.messageQueue.push(aMsg);
      ]]>
      </body>
     </method>

     <method name="_addMsg">
      <parameter name="aMsg"/>
      <body>
      <![CDATA[
        var conv = aMsg.conversation;
        if (!conv) {
          // The conversation has already been destroyed,
          // probably because the window was closed.
          // Return without doing anything.
          return;
        }
        var time = aMsg.time;
        var name = aMsg.alias ||aMsg.who;
        var pseudoClass = "pseudo";
        var color = "";
        if (aMsg.incoming) {
          var nick = conv.isChat && name.match(/[a-zA-Z0-9]+/);
          if (nick) {
            nick = nick[0].toLowerCase();
            var weight = 10;
            var res = 0;
            for (var i = 0; i < nick.length; ++i) {
               var char = nick.charCodeAt(i) - 47;
               if (char > 10)
                 char -= 39;
               // now char contains a value between 1 and 36
               res += char * weight;
               weight *= 0.52; //arbitrary
            }
            res = Math.round(res) % 360;
            color = " style=\"color: hsl(" + res + ", 100%, 50%)\"";
          }
          else
            pseudoClass += " incoming";
        }
        else
          if (aMsg.outgoing)
            pseudoClass += " outgoing";

        var msgClass = [];
        if (aMsg.system)
          msgClass.push("system");
        if (aMsg.containsNick)
          msgClass.push("nick");
        var txt = '<span class="date">' + time + '</span> ';

        var msg = aMsg.message;
        if (!aMsg.noLinkification) {
          msg = Components.classes["@mozilla.org/txttohtmlconv;1"]
                          .getService(Ci.mozITXTToHTMLConv)
                          .scanHTML(msg, 2)
                          .replace(/&amp;(apos|quot);/g, "&$1;");
        }

        var me = msg.match("^/me(.*)");
        if (!aMsg.system)
          txt += '<span class="' + pseudoClass + '"' + color + '>' + name  + (me ? "</span> " : ":</span> ");
      
        txt += (me ? me[1] : msg).replace(/\n/g, "<br/>");
        if (me)
          msgClass.push("me");

        this._addTxt(txt, msgClass.join(" "));

        if (this.tab && !this.tab.selected && aMsg.incoming && !aMsg.system) {
          if (conv.isChat && aMsg.containsNick)
            this.tab.setAttribute("attention", "true");
          else
            this.tab.setAttribute("unread", "true");
        }
      ]]>
      </body>
     </method>

     <method name="_addTxt">
      <parameter name="aTxt"/>
      <parameter name="aClass"/>
      <body>
      <![CDATA[
        if (!this.loaded)
          throw "Trying to append text to a not yet loaded browser";

        var browser = document.getAnonymousElementByAttribute(this, "anonid", "browser");
        var doc = browser.contentDocument;
        var elt = doc.getElementById("ibcontent");
        var newElt = doc.createElement("p");
        newElt.innerHTML = aTxt;
        newElt.className = aClass;
        var shouldScroll = elt.scrollHeight == elt.scrollTop + elt.clientHeight;
        elt.appendChild(newElt);
        if (shouldScroll)
          newElt.scrollIntoView(true);
      ]]>
      </body>
     </method>

     <method name="sendMsg">
      <parameter name="aMsg"/>
      <body>
      <![CDATA[
        var re = /^\/raw (.*)/;
        var msg = aMsg.match(re);
        if (msg)
          msg = msg[1];
        else
          msg = Components.classes["@mozilla.org/txttohtmlconv;1"]
                          .getService(Ci.mozITXTToHTMLConv)
                          .scanTXT(aMsg, 0);
        this._conv.sendMsg(msg);
      ]]>
      </body>
     </method>

     <method name="onSendMsg">
      <parameter name="event"/>
      <body>
      <![CDATA[
        if (event.keyCode != 13)
          return;

        /* this method is called by an eventListener.
           This points to the textbox element. */
        var conv = this;
        while (conv.localName != "conversation")
          conv = conv.parentNode;
        if (!event.ctrlKey && !event.shiftKey && !event.altKey) {
          conv.sendMsg(this.value);
          this.value = "";
          event.preventDefault();
        }
        else if (!event.shiftKey)
          this.value += "\n";
      ]]>
      </body>
     </method>

     <method name="onSendHTMLMsg">
      <parameter name="event"/>
      <body>
      <![CDATA[
        if (event.keyCode != 13)
          return;

        /* this method is called by an eventListener.
           This points to the textbox element. */
        var conv = this;
        while (conv.localName != "conversation")
          conv = conv.parentNode;

        var editor = this.getEditor(this.contentWindow);
        var docRoot = editor.rootElement;

        if (!event.ctrlKey && !event.shiftKey && !event.altKey) {
          conv.sendMsg(docRoot.innerHTML);
          docRoot.innerHTML = "";
          event.preventDefault();
        }
        else {
          if (!event.shiftKey)
            // unfortunately, this doesn't work
            this.contentDocument.execCommand("inserthtml", false, "<br>");
        }
      ]]>
      </body>
     </method>

     <method name="editorDoCommand">
      <parameter name="aCmd"/>
      <parameter name="aHtml"/>
      <body>
      <![CDATA[
        var editor = document.getAnonymousElementByAttribute(this, "anonid", "editor");
        editor.contentDocument.execCommand(aCmd, false, aHtml);
      ]]>
      </body>
     </method>

     <!-- nsIWebProgressListener implementation -->
     <method name="onStateChange">
      <parameter name="aProgress"/>
      <parameter name="aRequest"/>
      <parameter name="aStateFlags"/>
      <parameter name="aStatus"/>
      <body>
      <![CDATA[
        const WPL = Components.interfaces.nsIWebProgressListener;
        if ((aStateFlags & WPL.STATE_IS_DOCUMENT) &&
            (aStateFlags & WPL.STATE_STOP)) {
          var browser = document.getAnonymousElementByAttribute(this, "anonid", "browser");
          browser.removeProgressListener(this);
          this.loaded = true;
          for (var i = 0; i < this.messageQueue.length; ++i)
            this._addMsg(this.messageQueue[i]);
          this.messageQueue = null;
        }
      ]]>
      </body>
     </method>

     <method name="onProgressChange">
      <parameter name="aProgress"/>
      <parameter name="aRequest"/>
      <parameter name="aCurSelf"/>
      <parameter name="aMaxSelf"/>
      <parameter name="aCurTotal"/>
      <parameter name="aMaxTotal"/>
     </method>

     <method name="onLocationChange">
      <parameter name="aProgress"/>
      <parameter name="aRequest"/>
      <parameter name="aLocation"/>
     </method>

     <method name="onStatusChange">
      <parameter name="aProgress"/>
      <parameter name="aRequest"/>
      <parameter name="aStatus"/>
      <parameter name="aMessage"/>
     </method>

     <method name="onSecurityChange">
      <parameter name="aProgress"/>
      <parameter name="aRequest"/>
      <parameter name="aState"/>
     </method>

     <property name="convId">
       <getter>
         <![CDATA[
           return this._conv.id;
         ]]>
       </getter>
     </property>

     <property name="conv">
       <getter>
         <![CDATA[
           return this._conv;
         ]]>
       </getter>
       <setter>
         <![CDATA[
           this._conv = val;
           return val;
         ]]>
       </setter>
     </property>
    </implementation>
    <handlers>
     <handler event="focus" phase="capturing">
       <![CDATA[
         if (event.originalTarget != this)
           return;
         if (!this.hasAttribute("focused")) {
           var input = document.getAnonymousElementByAttribute(this, "anonid", "input");
           this.setAttribute("focused", "true");
           //FIXME: check why it doesn't work without this timeout
           setTimeout(function () {input.focus(); }, 1);
         }
        ]]>
      </handler>
      <handler event="blur" phase="capturing">
        <![CDATA[
          this.removeAttribute("focused");
        ]]>
      </handler>
    </handlers>
  </binding>

  <binding id="convtab" extends="chrome://global/content/bindings/tabbox.xml#tab">
    <resources>
      <stylesheet src="chrome://global/skin/tabbox.css"/>
    </resources>
    <content>
      <xul:hbox class="tab-image-left" xbl:inherits="selected"/>
      <xul:hbox flex="1" class="tab-image-middle" align="center" xbl:inherits="selected">
        <xul:stack class="tab-icon">
          <xul:image xbl:inherits="validate,src=image" class="tab-icon-image"/>
          <xul:image class="tab-extra-status"/>
        </xul:stack>
        <xul:label flex="1" xbl:inherits="value=label,crop,accesskey" crop="right" class="tab-text"/>
      </xul:hbox>
      <xul:hbox class="tab-image-right" xbl:inherits="selected"/>
    </content>
  </binding>
</bindings>

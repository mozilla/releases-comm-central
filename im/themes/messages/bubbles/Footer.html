<!-- This Source Code Form is subject to the terms of the Mozilla Public
   - License, v. 2.0. If a copy of the MPL was not distributed with this
   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->

<script type="text/javascript;version=1.7">
/* [pseudo_color, pseudo_background, bubble_borders] */
const elements_lightness = [[75, 94, 80], [75, 94, 80], [70, 93, 75], [65, 92, 70], [55, 90, 65], [48, 90, 60], [44, 86, 50], [44, 88, 60], [45, 88, 70], [45, 90, 70], [45, 92, 70], [45, 92, 70], [45, 92, 70], [45, 92, 70], [45, 92, 70], [45, 92, 70], [45, 92, 70], [45, 92, 70], [45, 92, 70], [60, 92, 70], [70, 93, 75], [75, 94, 80], [75, 94, 80], [75, 94, 80], [75, 94, 80], [75, 94, 80], [75, 94, 80], [75, 94, 80], [75, 94, 80], [75, 94, 80], [75, 94, 80], [75, 94, 80], [75, 94, 80], [75, 94, 80], [75, 94, 80], [75, 94, 80]];

const bubble_background = "hsl(#, 100%, 97%)";
const bubble_borders = "hsl(#, 100%, #%)";
const pseudo_color = "hsl(#, 100%, #%)";
const pseudo_background = "hsl(#, 100%, #%)";

var alternating = null;

function setColors(target)
{
  var senderColor = target.getAttribute("senderColor");

  if (!senderColor)
    return;

  var regexp = /color:\s*hsl\(\s*(\d{1,3})\s*,\s*\d{1,3}\%\s*,\s*\d{1,3}\%\s*\)/;
  var parsed = regexp.exec(senderColor);

  if (!parsed)
    return;

  var senderHue = ((Math.round(parsed[1]/10))*10)%360;
  var lightness = elements_lightness[senderHue/10];

  target.style.backgroundColor = bubble_background.replace("#", senderHue);
  target.style.borderColor = bubble_borders.replace("#", senderHue)
                                           .replace("#", lightness[2]);

  var pseudo = target.getElementsByClassName("pseudo")[0];
  pseudo.style.color = pseudo_color.replace("#", senderHue)
                                   .replace("#", lightness[0]);
  pseudo.style.backgroundColor = pseudo_background.replace("#", senderHue)
                                                  .replace("#", lightness[1]);

  var div_indicator = target.getElementsByClassName("indicator")[0];
  var imageURL = "url('Bitmaps/indicator_" + senderHue;
  if (target.classList.contains("incoming")) {
    // getComputedStyle is prohibitively expensive, and we need it only to
    // know if we are using an alternating variant, so we cache the result.
    if (alternating === null) {
      alternating = document.defaultView.getComputedStyle(div_indicator, null)
                            .backgroundImage.endsWith('_alt.png")') ? "_alt" : "";
    }
    imageURL += alternating;
  }
  div_indicator.style.backgroundImage = imageURL + ".png')";
}


function groupEvents(parent)
{
  var P_list = parent.getElementsByClassName("event");

  if (P_list.length < 4)
    return;

  var HR_list = parent.getElementsByTagName("hr");

  if (P_list[1].hasAttribute("style"))
  {
    var prevStyle = P_list[1].style.display;
    var nbEvents = P_list.length;

    P_list[nbEvents-2].style.display = prevStyle;
    HR_list[nbEvents-3].style.display = prevStyle;
  }
  else
  {
    var nbEvents = P_list.length;

    for (var i=1; i < (nbEvents-2); i++)
    {
      P_list[i].style.display = "none";
      HR_list[i].style.display = "none";
    }
    P_list[i].style.display = "none";

    var p = document.createElement("p");
    p.addEventListener("click", toggle_groupEvents);
    p.setAttribute("class", "button hide");
    parent.insertBefore(p, P_list[1]);
  }
}


function toggle_groupEvents(aEvent)
{
  if (aEvent.detail > 1)
    return;

  var target = aEvent.target;
  var P_list = target.parentNode.getElementsByClassName("event");
  var HR_list = target.parentNode.getElementsByTagName("hr");
  var nbEvents = P_list.length;

  if (target.className == "button hide") {
    for (var i=1; i < (nbEvents-2); i++) {
      P_list[i].style.display = "block";
      HR_list[i].style.display = "block";
    }
    P_list[i].style.display = "block";

    target.className = "button show";
  }
  else {
    for (var i=1; i < (nbEvents-2); i++) {
      P_list[i].style.display = "none";
      HR_list[i].style.display = "none";
    }
    P_list[i].style.display = "none";

    target.className = "button hide";
  }
}

function prettyPrintTime(aValue, aNoSeconds) {
  if (aValue < 60 && aNoSeconds)
    return "";

  if (aNoSeconds)
    aValue -= aValue % 60;

  let valuesAndUnits = window.convertTimeUnits(aValue);
  if (!valuesAndUnits[2])
    valuesAndUnits.splice(2, 2);
  return valuesAndUnits.join(" ");
}

// The "shadow" constant is the minimum acceptable margin-bottom for a bubble
// with a shadow, and the minimum spacing between the bubbles of two messages
// arriving in the same second. It should match the value of margin-bottom and
// box-shadow-bottom for the "bubble" class.
const shadow = 3;
const coef = 3;
const timebeforetextdisplay = 5 * 60;
const kRulerMarginTop = 11;

const kMsPerMinute = 60 * 1000;
const kMsPerHour = 60 * kMsPerMinute;
const kMsPerDay = 24 * kMsPerHour;

function computeSpace(aInterval)
  Math.round(coef * Math.log(aInterval + 1))

function refreshIntervals()
{
  var pixels = 1;
  while (true) {
    var time = Math.exp((pixels - 0.49999) / coef) - 1;
    if (time >= timebeforetextdisplay)
      break;

    yield Math.round(time * 1000);
    ++pixels;
  }
}

var refreshTimes;
var lastMessageTimeout;
function handleLastMessage()
{
  if (window.messageInsertPending)
    return;

  var intervalInMs = Date.now() - lastInsertTime * 1000;
  var interval = Math.round(intervalInMs / 1000);
  var p = document.getElementById("lastMessage");
  var margin = computeSpace(Math.max(intervalInMs, 0) / 1000);
  var text = "";
  if (interval >= timebeforetextdisplay) {
    p.style.lineHeight = (margin + shadow) + "px";
    p.setAttribute("class", "interval");
    text = prettyPrintTime(interval, true);
    margin = 0;
  }
  p.textContent = text;
  p.style.marginTop = (margin - shadow) + "px";
  var body = document.getElementsByTagName("body")[0];
  if (body.scrollHeight <= body.scrollTop + body.clientHeight + p.clientHeight + 10)
    scrollToElement(p);

  var next = 0;
  if (interval < timebeforetextdisplay) {
    if (!refreshTimes)
      refreshTimes = [i for (i in refreshIntervals())];
    for (var i = 0; i < refreshTimes.length; ++i) {
      if (refreshTimes[i] > intervalInMs) {
        next = refreshTimes[i] - intervalInMs;
        break;
      }
    }
  }
  if (!next) {
    if (intervalInMs > kMsPerDay)
      next = kMsPerHour - intervalInMs % kMsPerHour;
    else
      next = kMsPerMinute - intervalInMs % kMsPerMinute;
  }

  // The setTimeout callbacks are frequently called a few ms early,
  // but our code prefers being called a little late, so add 20ms.
  lastMessageTimeout =
    setTimeout(handleLastMessage, next + 20);
}

var lastInsertTime = 0;
function updateLastInsertTime()
{
  let insertTime = document.getElementById("insert").getAttribute("time");
  if (insertTime > lastInsertTime)
    lastInsertTime = insertTime;

  if (lastInsertTime) {
    clearTimeout(lastMessageTimeout);
    if (!document.hidden)
      lastMessageTimeout = setTimeout(handleLastMessage, 0);
  }
}

function visibilityChanged()
{
  if (document.hidden)
    clearTimeout(lastMessageTimeout);
  else if (lastInsertTime)
    handleLastMessage();
}

function checkNewText(aEvent)
{
  var target = aEvent.originalTarget;
  if (!(target instanceof HTMLElement))
    return;

  var nicks = target.getElementsByClassName("ib-nick");
  for (var i = 0; i < nicks.length; ++i) {
    var nick = nicks[i];
    if (nick.hasAttribute("left"))
      continue;
    var hue = nick.getAttribute("nickColor");
    var senderHue = ((Math.round(hue / 10)) * 10) % 360;
    var lightness = elements_lightness[senderHue / 10];
    nick.style.backgroundColor = pseudo_background.replace("#", senderHue).replace("#", lightness[1]);
    nick.style.color = pseudo_color.replace("#", senderHue).replace("#", lightness[0]);
    nick.style.borderColor = bubble_borders.replace("#", senderHue).replace("#", lightness[2]);
  }

  if (target.tagName == "DIV" && target.classList.contains("bubble")) {
    setColors(target);

    var prev = target.previousSibling;
    var shouldSetUnreadRuler = prev && prev.id && prev.id == "unread-ruler";
    var shouldSetSessionRuler = prev && prev.className && prev.className == "sessionstart-ruler";
    // We need an extra pixel of margin at the top to make the margins appear
    // to be of equal size, since the preceding bubble will have a shadow.
    var rulerMarginBottom = kRulerMarginTop - 1;

    var insertTime = document.getElementById("insert").getAttribute("time");
    if (lastInsertTime && insertTime >= lastInsertTime) {
      var interval = insertTime - lastInsertTime;
      var margin = computeSpace(interval);
      let isTimetext = interval >= timebeforetextdisplay;
      if (isTimetext) {
        var p = document.createElement("p");
        p.className = "interval";
        if (shouldSetSessionRuler) {
          // Hide the hr and style the time text accordingly instead.
          prev.classList.remove("sessionstart-ruler");
          prev.style.border = "none";
          p.classList.add("sessionstart-ruler");
          margin += 6;
          prev = p;
        }
        p.style.lineHeight = (margin + shadow) + "px";
        p.style.marginTop = -shadow + "px";
        p.textContent = prettyPrintTime(interval);
        target.parentNode.insertBefore(p, target);
        margin = 0;
      }
      target.style.marginTop = margin + "px";
      if (shouldSetUnreadRuler || shouldSetSessionRuler) {
        if (margin > rulerMarginBottom) {
          // Set the unread ruler margin so it is constant after margin collapse.
          // See https://developer.mozilla.org/en/CSS/margin_collapsing
          rulerMarginBottom -= margin;
        }
        if (isTimetext && shouldSetUnreadRuler) {
          // If a text display follows, use the minimum bubble margin after the
          // ruler, taking account of the absence of a shadow on the ruler.
          rulerMarginBottom = shadow - 1;
        }
      }
    }
    updateLastInsertTime();
    if (shouldSetUnreadRuler || shouldSetSessionRuler) {
      prev.style.marginBottom = rulerMarginBottom + "px";
      prev.style.marginTop = kRulerMarginTop + "px";
    }
  }
  else if (target.tagName == "DIV" && target.id == "insert") {
    updateLastInsertTime();
  }
  else if (target.tagName == "P" && target.className == "event") {
    groupEvents(target.parentNode);
    updateLastInsertTime();
  }
}

document.getElementById("ibcontent")
        .addEventListener("DOMNodeInserted", checkNewText);
document.addEventListener("visibilitychange", visibilityChanged);
</script>

<p id="lastMessage"/>
